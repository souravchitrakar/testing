Git Bash is a tool that emulates a Bash experience on a Windows machine. And of course it comes with a Git too.
Configure name and email in Git.
A Git Repo is a workspace which tracks and manages files within a folder (so Git Repo is created inside a folder to track and manage objects inside it).
When we initiate a Git Repo in a folder, a .git folder will be created. If we delete the .git, the Git Repo will be deleted.
Git Repo tracks a directory and all nested subdirectories. So before initiating a Git Repo check the status to make sure you are not inside any Git Repo already.
Working Directory - We define .git in a directory, that directory or any subdirectory where we are working is called Working Directory.
Repository - The .git is the Repository.
Staging Area - It is present in between Working Directory and Repository.
To take a file from Working Directory to Staging Area we need "git add". We use the "git commit" command to actually commit changes from the Staging Area to Repository.
If we modify a file which is already committed using "git commit" then it will be listed as "modified" when we check using "git status". A newly added file will be shown as "untracked" when we check using "git status". If we delete a file which is already committed using "git commit" then it will be listed as "deleted" when we check using "git status".
If we modify a file which is already added to Staging Area using "git add" then it will be listed as "modified" when we check using "git status". The file which is already present in Staging Area will be as it is when we check using "git status". At this moment two things can take place, one, if we commit the staged file will move to Repository. Two, if we add the modified file it will overwrite the file in Staging Area. The behaviour is exactly same for file deletion as well.
We can only amend the last Commit by using "git commit --amend" command. This will open the last commit's message and commit what so ever present in current Staging Area.
Create a file called ".gitignore" in the root of a Repository (root Directory). Inside the file we can write the patterns to tell git which files and directories to ignore: ".DS_Store" will ignore files named ".DS_Store", "folderName/" will ignore the entire "folderName/" directory (/ at the end tells that it is a Directory in Git world), "*.log" will ignore any files with the extension ".log". Git itself will tract ".gitignore" file as a regular file.
In Git we are always working on a branch. The default branch name is Master (it is just like any other branch).
We will often come across the term "Head" in Git. "Head" is simply a pointer that refers to the current location in your Repository (always points to the latest commit you made). It points to a particular branch reference.
Multiple Branches can point to a single Commit Point.
If we create a new file from any Branch (even if the file is added to the Staging Area), we can switch to any other Branch and Commit it as it is not having any Branch as owner (in the switched Branch we will be able to see the file in same state either in Working Directory or Staging Area where it was before switching the Branch).
If we have a file in modified or deleted state in a Branch (even if the file is added to the Staging Area), we only can switch to the Branches which are having same version of the file, else Git will restrict (in the switched Branch we will be able to see the file in same state either in Working Directory or Staging Area where it was before switching the Branch).
We can not delete a Branch if it is checked out (already in that Branch).
To rename a Branch first we need to switch to the same Branch.
Switch to the Branch you want to merge the changes into.
A Fast-Forward Merge is the simplest way Git combines two branches. It happens when the branch you are merging into (e.g., main) has no new commits since you created your feature branch. Instead of doing a complex "merge," Git realizes it can just move the branch pointer forward to the latest commit of your feature branch.
A Merge Commit is a special type of commit that Git creates when it combines two separate histories that have diverged. Unlike a normal commit, which has only one parent (the commit that came before it), a merge commit has two or more parents. It acts as a bridge that ties two different lines of development together.
Stashing: Git provides an easy way of stashing these uncommited changes so that we can return to them later (it should be used to quickly switch to other branch without commiting the changes in current branch), without having to make unnecessary commits. The command "git stash" makes the working tree clean. Git stash is common to the entire repository, not specific to any individual branch. When you run git stash, your changes are saved to a global stack for that local repository (that is why git stash pop and git stash apply can be used on a different branch from the one where the changes were originally stashed, If a conflict occurs while applying or popping a stash on a different branch, Git handles it with a safety mechanism to prevent data loss). You can add multiple stashes onto the stack of stashes.
Head generally points to a specific Branch reference rather than a particular Commit. Under normal conditions, HEAD points to a branch (e.g., main), which in turn points to the latest commit on that branch. In Git, a detached HEAD state occurs when your HEAD pointer points directly to a specific commit hash instead of a branch reference (git status will return HEAD detached).

By default, when you run git clone, Git downloads all branches and the entire commit history from the remote repository. However, it only checks out the default branch (usually main or master) into your working directory.
We need to create a Remote in our local Git Repository to communicate with GitHub.
The origin/main is a local photocopy of the main branch on the server. Even though it has the word "origin" in it, the origin/main (actually all the branches have origin/branchname) pointer actually lives on your computer, not on GitHub. It is Git's way of remembering: "The last time I talked to the server, this is where the main branch was."
If git clone is how you get the whole book, and origin/main is your bookmark of the last page you read, then git fetch is like checking the library catalog to see if any new chapters have been added since you last looked. When you run git fetch origin, Git does two things: i. downloads the Data - it downloads all new commits, files, and tags from the remote server. ii. updates the "Bookmarks" - it moves your remote-tracking branches (like origin/main or origin/feature-xyz) forward to match the server's state.
